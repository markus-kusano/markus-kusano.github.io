<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ece2524 | Markus Kusano]]></title>
  <link href="http://markus-kusano.github.io/blog/categories/ece2524/atom.xml" rel="self"/>
  <link href="http://markus-kusano.github.io/"/>
  <updated>2014-07-07T20:00:56-04:00</updated>
  <id>http://markus-kusano.github.io/</id>
  <author>
    <name><![CDATA[Markus Kusano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Balanced Brace Checker]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/11/26/a-balanced-brace-checker/"/>
    <updated>2013-11-26T12:30:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/11/26/a-balanced-brace-checker</id>
    <content type="html"><![CDATA[<p>Recently in Intro to Unix we had to implement a balanced brace checker.
Specifically, the tool was supposed to ensure that every opening brace has a
matching closing brace and vice versa.</p>

<p>This is a fairly common assignment, though I had never actually done it before.
I was introduced to in Virginia Tech&rsquo;s second year programming course (data
structures and algorithms) as an introduction to recursive (or stack) based
algorithms. I think some recent classes in Data Structures actually had this as
an assignment so I can guess why we would do it again. It lets the student see
how they could have made their original implementation follow the Unix design
philosophy.</p>

<h2>Intro to Unix&rsquo;s Position in Undergrad Curriculum</h2>

<p>Intro to Unix has an interesting position in the undergrad Computer Engineering
curriculum since it is not a pre-requisite for any class. I&rsquo;ve actually
finished taking all my programming courses this semester so it makes me wonder
the benefits of learning about fundamental design patterns so late. Of course
in future work I could apply these ideas but I believe it would have been
better to have some time to practice these ideas in school.</p>

<p>I really believe many of the core Unix design concepts are important to making
modern and scalable code, especially the concepts of modularity. In my mind,
Modularity goes hand-in-hand with code written in a <em>purely functional</em> style.</p>

<h2>Pure Functions</h2>

<p>Pure functions are completely compartmentalized: you pass in data and you get
out data. For example, I would hope the function <code>add(int a, int b)</code> is a pure
function returning  <code>a + b</code>. There are no flags in the code or assumptions
made, the function always does the same thing. There is basically no state
maintained across function calls.</p>

<h3>Parallelization</h3>

<p>This can be useful because if there is no state, or if the state is all
internal to the function, then there is no synchronization required. These are
so called embarrassingly parallel (or trivially parallel) problems. Imposing
<em>order</em> on a multi-threaded or distributed system is a expensive. The
<a href="http://www.bloom-lang.net/">Bloom</a> programming language makes it easy to see
these points of order allowing you to reduce them and make things scale.</p>

<p>John Carmack, creator of games like Doom, Quake and Commander Keen, speaking at
Quakecon 2013, outlines a similar vision for how functional programming can
aide in speedier game development for just these reasons
(<a href="http://youtu.be/1PhArSujR_A">Video</a>). Of course you don&rsquo;t actually need a
programming language that enforces pure functional style as on long as the team
you are working with does not break the rules.</p>

<p>Carmack makes the point that writing in a functional style is difficult, or
at least different, especially when coming from procedural languages like Java
or C. Its not like a team can just sit down with
<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a> and pump out thousands of
games overnight. It will take a lot of work to iron out the details of working
in this style.</p>

<h2>Our Curriculum</h2>

<p>So, how does all of this relate to our classes? If we are only briefly
introduced to design concepts, such as modularity, that are perhaps difficult
to implement but rewarding in the long run then how can we expect to use them
without more practice? I&rsquo;m guessing we&rsquo;d need some classes where we are
required to write in this style in order for it to become closer to second
nature. What about when you are introduced to these concepts right before
you&rsquo;re graduating? Will you really use them later in life?</p>

<p>Of course, being able to hack out a homework assignment or project quickly
means taking shortcuts. It means it will be held together with duct tape, and
this is how real software is made. So I&rsquo;m not really sure what the best course
of action would be.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASE 2013]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/11/07/ase-2013/"/>
    <updated>2013-11-07T15:12:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/11/07/ase-2013</id>
    <content type="html"><![CDATA[<p>I was very lucky to be accepted for the tool demos at Automated Software
Engineering 2013. I get to spend a week in California, hopefully eat some good
food and learn about some other work people have been doing.</p>

<h2>CCmutator</h2>

<p>Our tool is a concurrent mutant generator for C/C++ and is named CCmutator.
What it does is automatically make syntactical changes to source code in order
to (hopefully) insert bugs into a program. This may sound like a really strange
thing to do at first, but we hope our tool can be used for test case generation
for software verification algorithms.</p>

<p>Finding real world bugs is difficult. It involves going on bug trackers for
large projects like mozilla, reading bug reports, figuring out what is going
on, and wrapping your head around huge codebases that you&rsquo;ve never worked on
before. Our tool will hopefully be able to help speed this up. If you have an
input program that you understand, then we can automatically generate some
potentially buggy programs.</p>

<p>This begs the question of whether or not these mutant programs actually
represent real world bugs made by actual programmers.</p>

<p>Here is a link to the preprint for my paper if you are interested.</p>

<p><a href="https://raw.github.com/markus-kusano/markus-kusano.github.com/master/papers/CCmutator_ase2013_preprint.pdf">CCmutator ASE 2013 Preprint</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Art of Unix Programming Nuggets]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/08/29/art-of-unix-programming-nuggets/"/>
    <updated>2013-08-29T13:56:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/08/29/art-of-unix-programming-nuggets</id>
    <content type="html"><![CDATA[<blockquote><p>One of the many consequences of the exponential power-versus-time curve in
computing, and the corresponding pace of software development, is that 50% of
what one knows becomes obsolete over every 18 months. Unix does not abolish
this phenomenon, but does do a good job of containing it. There&rsquo;s a bedrock
of unchanging basics&mdash;-languages, system calls, and tool invocations&mdash;-that
one can actually keep using for years, even decades.</p></blockquote>

<p>How much of our education here will be effected by 50% decay in 18 months? We
already are seeing courses being changed (intro to computer engineering,
digital design one and two) and there is talk about the software track (1574,
2574, 3574) being altered as well. These changes, particularly the switch to
FPGAs over programmable logic devices, give great opportunity for us to complain
about walking uphill both ways and to be arrogant about our skills in getting
WinCUPL to work (did you try turning it on and off again?); but, this isn&rsquo;t
very productive.</p>

<p>Overall, this is perhaps more of a general education question that might be
difficult to address directly in an introduction to Unix course but I think it
is an interesting thought to keep in mind while being a full-time student.</p>

<p>Related to this is:</p>

<blockquote><p>Rule of Extensibility: Design for the future, because it will be here sooner
than you think.</p></blockquote>

<p>This rule is something that can be addressed in intro to Unix. The text
surrounding this rule emphasizes quick prototyping (&ldquo;Make it run, then make it
right, then make it fast&rdquo;). My programming knowledge is largely in C/C++, which
is a very comfortable environment to me. I can hack on a python script written
by someone else but I&rsquo;m not familiar with all the different ways higher level
languages can quickly create solutions.</p>

<p>The author also talks about a strategy of making the backend a C library and
the frontend possibly a high-level language calling into this library. I think
it would be nice to learn how to do this (communication over sockets, calling C
code from python)</p>

<p>Quotes from The Art of Unix Programming.
<a href="http://catb.org/esr/writings/taoup/html/">http://catb.org/esr/writings/taoup/html/</a></p>
]]></content>
  </entry>
  
</feed>
