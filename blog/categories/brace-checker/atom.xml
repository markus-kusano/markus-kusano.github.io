<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: brace checker | Markus Kusano]]></title>
  <link href="http://markus-kusano.github.io/blog/categories/brace-checker/atom.xml" rel="self"/>
  <link href="http://markus-kusano.github.io/"/>
  <updated>2014-01-31T08:23:22-05:00</updated>
  <id>http://markus-kusano.github.io/</id>
  <author>
    <name><![CDATA[Markus Kusano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Balanced Brace Checker]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/11/26/a-balanced-brace-checker/"/>
    <updated>2013-11-26T12:30:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/11/26/a-balanced-brace-checker</id>
    <content type="html"><![CDATA[<p>Recently in Intro to Unix we had to implement a balanced brace checker.
Specifically, the tool was supposed to ensure that every opening brace has a
matching closing brace and vice versa.</p>

<p>This is a fairly common assignment, though I had never actually done it before.
I was introduced to in Virginia Tech&rsquo;s second year programming course (data
structures and algorithms) as an introduction to recursive (or stack) based
algorithms. I think some recent classes in Data Structures actually had this as
an assignment so I can guess why we would do it again. It lets the student see
how they could have made their original implementation follow the Unix design
philosophy.</p>

<h2>Intro to Unix&rsquo;s Position in Undergrad Curriculum</h2>

<p>Intro to Unix has an interesting position in the undergrad Computer Engineering
curriculum since it is not a pre-requisite for any class. I&rsquo;ve actually
finished taking all my programming courses this semester so it makes me wonder
the benefits of learning about fundamental design patterns so late. Of course
in future work I could apply these ideas but I believe it would have been
better to have some time to practice these ideas in school.</p>

<p>I really believe many of the core Unix design concepts are important to making
modern and scalable code, especially the concepts of modularity. In my mind,
Modularity goes hand-in-hand with code written in a <em>purely functional</em> style.</p>

<h2>Pure Functions</h2>

<p>Pure functions are completely compartmentalized: you pass in data and you get
out data. For example, I would hope the function <code>add(int a, int b)</code> is a pure
function returning  <code>a + b</code>. There are no flags in the code or assumptions
made, the function always does the same thing. There is basically no state
maintained across function calls.</p>

<h3>Parallelization</h3>

<p>This can be useful because if there is no state, or if the state is all
internal to the function, then there is no synchronization required. These are
so called embarrassingly parallel (or trivially parallel) problems. Imposing
<em>order</em> on a multi-threaded or distributed system is a expensive. The
<a href="http://www.bloom-lang.net/">Bloom</a> programming language makes it easy to see
these points of order allowing you to reduce them and make things scale.</p>

<p>John Carmack, creator of games like Doom, Quake and Commander Keen, speaking at
Quakecon 2013, outlines a similar vision for how functional programming can
aide in speedier game development for just these reasons
(<a href="http://youtu.be/1PhArSujR_A">Video</a>). Of course you don&rsquo;t actually need a
programming language that enforces pure functional style as on long as the team
you are working with does not break the rules.</p>

<p>Carmack makes the point that writing in a functional style is difficult, or
at least different, especially when coming from procedural languages like Java
or C. Its not like a team can just sit down with
<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a> and pump out thousands of
games overnight. It will take a lot of work to iron out the details of working
in this style.</p>

<h2>Our Curriculum</h2>

<p>So, how does all of this relate to our classes? If we are only briefly
introduced to design concepts, such as modularity, that are perhaps difficult
to implement but rewarding in the long run then how can we expect to use them
without more practice? I&rsquo;m guessing we&rsquo;d need some classes where we are
required to write in this style in order for it to become closer to second
nature. What about when you are introduced to these concepts right before
you&rsquo;re graduating? Will you really use them later in life?</p>

<p>Of course, being able to hack out a homework assignment or project quickly
means taking shortcuts. It means it will be held together with duct tape, and
this is how real software is made. So I&rsquo;m not really sure what the best course
of action would be.</p>
]]></content>
  </entry>
  
</feed>
