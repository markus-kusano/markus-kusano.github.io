<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: microcontrollers | Markus Kusano]]></title>
  <link href="http://markus-kusano.github.io/blog/categories/microcontrollers/atom.xml" rel="self"/>
  <link href="http://markus-kusano.github.io/"/>
  <updated>2014-06-14T22:13:38-04:00</updated>
  <id>http://markus-kusano.github.io/</id>
  <author>
    <name><![CDATA[Markus Kusano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Logic Analyzer Instrumentation: Realtime Systems]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/10/11/logic-analyzer-instrumentation/"/>
    <updated>2013-10-11T16:45:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/10/11/logic-analyzer-instrumentation</id>
    <content type="html"><![CDATA[<h2>What is a Logic Analyzer</h2>

<p>A logic analyzer captures and displays digital signals. You plug in a logic
analyzer input cable on another cable carrying some digital signal and the
analyzer will store the signal over some period of time.</p>

<p>A fancy analyzer will be able to decode protocols such as I2C but this is not
the focus of this post.</p>

<h2>Debugging Realtime Systems on a Microcontroller</h2>

<p>One of the broad problems with any program, not only on microcontrollers, is
pinpointing what causes an error. The problem is exacerbated on realtime
systems because a standard debugger inserting breakpoints changes timing
characteristics and the control flow of the program. It is similar to the
non-determinism introduced into multi-threaded programs due to thread
scheduling.</p>

<p>For example, if you set a breakpoint in the middle of an I2C protocol state
machine in a state waiting for the slave to ACK or NACK could possibly cause
hardware to timeout thinking that the slave has died when in reality it was the
debugger stalling the program.</p>

<p>In the past I&rsquo;ve gotten around this by constantly move breakpoints and then
restarting the microcontroller to see control flow to pinpoint where an error
has occurred. This is obviously time consuming and involves a lot of clicking.</p>

<p>One was to see control flow on conventional programs is to create a log file.
On a microcontroller that has no display this is difficult but a similar
approach can be taken using code instrumentation.</p>

<h2>Code Instrumentation</h2>

<p>Most microcontrollers provide general purpose input/output (GPIO) pins. These
can be hooked up to a logic analyzer to act as flags for different points in a
program by setting them high or low. For example, you could add instrumentation
to drive a pin high when you are in an interrupt handler accepting incoming
data and then drive another pin high when the data is being processed outside
the interrupt handler.</p>

<p>This allows you to see <em>causality</em>. Event A stores incoming data into a buffer
and then Event B processes the data. More importantly this lets you see
failures in your causality relationships; the data comes in and is passed into
a buffer but it fails to be processed.</p>

<p>It will also provide timing information to see if you can meet your timing
requirements and also see areas of your system that are eating up a lot of time.</p>

<h2>You Don&rsquo;t Even Need a Logic Analyzer</h2>

<p>Simple code instrumentation like this can be done by driving an LED high off a
GPIO pin. This is a little bit more messy to setup and you don&rsquo;t get any buffer
to save your data (you could video tape the LEDs) but it is much cheaper than a
logic analyzer.</p>
]]></content>
  </entry>
  
</feed>
