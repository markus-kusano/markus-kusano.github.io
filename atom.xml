<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Markus Kusano]]></title>
  <link href="http://markus-kusano.github.io/atom.xml" rel="self"/>
  <link href="http://markus-kusano.github.io/"/>
  <updated>2014-05-25T15:27:15-04:00</updated>
  <id>http://markus-kusano.github.io/</id>
  <author>
    <name><![CDATA[Markus Kusano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
    <title type="html"><![CDATA[Baking Bread]]></title>
    <link href="http://markus-kusano.github.io/blog/2014/01/28/baking-bread/"/>
    
    <updated>2014-01-28T09:52:32-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2014/01/28/baking-bread</id>
    
    <content type="html"><![CDATA[<p>All my posts have been very serious. Here is some easy to read documentation of
my experience baking free wild yeast bread.</p>

<p>In the past, I&rsquo;ve baked bread with commercial yeast, which are the little brown
balls that you dissolve in water to create bubbles. I usually used a fairly
good amount of yeast so that the rise times were quick (a few hours).</p>

<p>I read Chad Robertson&rsquo;s cookbook <em>Tartine Bread</em> which documents basically the
opposite process: wild yeast and long, slow rises.</p>

<h2>Wild Yeast</h2>

<p>I decided to just give it a shot; take flour and water mix it up with your
hands and put it in a bowl. After a few days it should start bubbling.
Surprisingly it did. Surprisingly when I ate some it didn&rsquo;t cause me vomit
instantly. I created my own wild yeast starter.</p>

<p>Over the course of about 2 weeks, everyday I would discard around 30% of the
starter and feed it more flour and warm water. It would start bubbling
throughout the day and change in smell from floury, to sweet and milky to
stinky cheese by the next morning.</p>

<h2>Baking Bread: Robertson&rsquo;s Basic Country Loaf</h2>

<p>The first step is creating a leaven. Basically, a bunch of flour and your
starter that is given plenty of time to bubble up and get plenty of carbon
dioxide trapped in it.</p>

<p>I left the flour, water and starter sit overnight but it wasn&rsquo;t ready in the
morning. I put it in my oven with some boiling water to make a proof box and,
again surprisingly, it worked.</p>

<p><img src="http://farm8.staticflickr.com/7446/12153776365_f795b074a9_b.jpg"></p>

<p>Here is the leaven after a few hours in the steamy oven.</p>

<p><img src="http://farm8.staticflickr.com/7335/12154155354_3bdfd34bc0_c.jpg"></p>

<p>It&rsquo;s supposed to be able to float in water, and I think it got close enough.</p>

<p><img src="http://farm8.staticflickr.com/7314/12154124923_2975ea136b_c.jpg"></p>

<p>Here&rsquo;s the dough with the all the flour and water:</p>

<h3>Bulk Rise</h3>

<p>After that, it was pretty much just waiting and mixing. I did a bulk rise for
three and a half hours, turning the dough every 30 minutes.</p>

<p>As time progresses, you can watch the dough tighten up and get smooth.</p>

<h3>Start</h3>

<p><img src="http://farm8.staticflickr.com/7344/12154144803_5f603a17c0_c.jpg"></p>

<p><img src="http://farm6.staticflickr.com/5482/12154597576_e6a2d50034_c.jpg"></p>

<p>Here&rsquo;s two shots of the dough in the bowl at the start of the bulk rise.</p>

<h3>Hour One</h3>

<p><img src="http://farm4.staticflickr.com/3827/12155498834_8de5b3832f_c.jpg"></p>

<h3>Hour Three</h3>

<p><img src="http://farm8.staticflickr.com/7399/12157138386_0637999aef_c.jpg"></p>

<h2>Bench Rest</h2>

<p><img src="http://farm8.staticflickr.com/7444/12157779113_5f55f3875f_c.jpg"></p>

<p>After the bulk rise, the dough is split in two and plopped on the counter.</p>

<p><img src="http://farm4.staticflickr.com/3689/12163496193_d6460dba1e_c.jpg"></p>

<p>Surprisingly, it holds its shape pretty well and doesn&rsquo;t just droop everywhere.
It was pretty hard forming the dough into rounds since it is very sticky.</p>

<h2>Final Rise</h2>

<p><img src="http://farm8.staticflickr.com/7357/12163914686_a1cc162252_c.jpg"></p>

<p>After about 30 minutes on the counter, the dough rests for another three to
four hours in a nice bowl with a comfy towel.</p>

<h2>500 Degrees in a Dutch Oven</h2>

<p><img src="http://farm3.staticflickr.com/2891/12163491953_fdaa6a992b_c.jpg"></p>

<p><img src="http://farm4.staticflickr.com/3733/12163490983_17a2af733f_c.jpg"></p>

<p><img src="http://farm3.staticflickr.com/2841/12163668994_c74833164c_c.jpg"></p>

<p><img src="http://farm6.staticflickr.com/5482/12163910526_681a64f170_c.jpg"></p>

<p><img src="http://farm6.staticflickr.com/5498/12163248455_6933c1ce64_c.jpg"></p>

<p><img src="http://farm4.staticflickr.com/3733/12163490983_17a2af733f_c.jpg"></p>

<p>I didn&rsquo;t get the crazy oven spring that some people show. Maybe I let it rise
too long or didn&rsquo;t give it rigorous enough turns. Overall, I&rsquo;m more than
satisfied. I ate one of the loafs in the few hours after it came out of the
oven.</p>

<p>I like making bread because its the opposite of what I work on. Its not by the
numbers, you have to be flexible and watch how things develop. No math and no
formulas.</p>

<p>More photos and full resolution available here:</p>

<p><a href="http://www.flickr.com/photos/115578628@N06/sets/72157640173083656/">http://www.flickr.com/photos/115578628@N06/sets/72157640173083656/</a></p>

<p>Apologies, some of them are kind of blurry.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Learning Programming]]></title>
    <link href="http://markus-kusano.github.io/blog/2014/01/03/learning-programming/"/>
    
    <updated>2014-01-03T10:59:18-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2014/01/03/learning-programming</id>
    
    <content type="html"><![CDATA[<p>A friend recently told me he wanted to learn how to program and use a
unix-like. He asked me to checkout a <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/">Intro to Algorithms</a>,
an open course from MIT. I watched a video on a subject I didn&rsquo;t really know
and it was interesting. Of course it&rsquo;s a class on algorithms so it is probably
pretty high level compared to a course on embedded devices.</p>

<p>I learned how to program three or four years ago during summer break from
reddit&rsquo;s <a href="reddit.com/r/carlhprogramming">Carl H. Programming</a>. His course is
taught in C and had a decent amount of exercises. He pushed pointers and
multi-dimensional arrays from the start which was really useful, especially
once I started doing more C programming on micro-controllers. When I was using
it, the course was never finished and abruptly ended with recursive algorithms
with a tic-tac-to project. A year ago I got some closure when I programmed a
tic-tac-to board and AI (min-max) in C++.</p>

<p>This reminded me of something I read about reading literature. That it doesn&rsquo;t
really matter if you read something and understand <em>everything</em> but more
importantly that you understand something. The context was more like a kid
reading <em>Gravity&rsquo;s Rainbow</em> than a kid reading <em>Structure and Interpretation of
Computer Programs</em> but I wonder if the idea still holds weight for technical
material. For something as vast as programming, especially when your goal is
&ldquo;learn programming&rdquo; and nothing specific maybe just reading material and seeing
what sticks is the best way to do it. Will the important topics rise to the top
so that even if you miss it the first time maybe on the third or fourth you&rsquo;ll
get it?</p>

<p>At the very least, I think its good to avoid spending too much time on trying
to find the best textbook or video series to use. This probably goes for many
things other than learning; I&rsquo;ve found myself drained of energy browsing
Netflix for something to watch that I just give up. Obviously, counter
productive to entertainment.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Shades of Cheating]]></title>
    <link href="http://markus-kusano.github.io/blog/2014/01/03/cheating/"/>
    
    <updated>2014-01-03T09:25:13-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2014/01/03/cheating</id>
    
    <content type="html"><![CDATA[<p>I was always fairly willing, unless I got too lazy, to help out my friends with
their projects. I got a great deal of help myself too. But, I wonder if I did a
disservice to my friends by helping them too much on their homework. Would they
have learned more by failing? Did they actually want help or just the answer?
You can get into a sort of paranoid state if you think too much about if people
around you want honest help or want you to do their homework for you. For me,
seeing that low-grade and a big X on a returned assignment really helped me. It
showed me exactly what I didn&rsquo;t know. The solution is always really obvious
when its right in front of you; its too easy to just say, &ldquo;oh I can do that,&rdquo;
and copy it down. But I don&rsquo;t think you actual learn anything from this.</p>

<h2>What to work on</h2>

<p>One observation I&rsquo;ve had is that when it comes to finish homework there are two
categories you can focus your time in: solving the problem or finding the
solutions manual. Both of them involve spending time to finish the task at
hand. I&rsquo;ve gotten the feeling that some people would spend <em>more</em> time trying
to find the answer rather than learning how to solve the problem. There are
obvious pay-offs to finding the solution: you&rsquo;re pretty much guaranteed to get
an A (perhaps getting caught cheating too). There are obvious pay-offs to
getting an A, an employer will give you money. This idea of learning versus
solutions manual can be extended to other parts of being a student like study
for a test or store all the equations in my calculator.</p>

<p>When it comes to straight cheating, like using your phone to look up answers
during a test, the comparison doesn&rsquo;t seem to be two different areas where you
can put in your time into. Perhaps instead of time you pay the stress of
getting caught. Regardless, time spent finding a solution or just plain
cheating doesn&rsquo;t seem productive to actually learning.</p>

<p>The <em>worst</em> part is that there are people who did learn by failing. Who didn&rsquo;t
get someone else to do their homework, who didn&rsquo;t come to a group to
check answers with a blank sheet and who spent more time trying to figure out
the problems than trying to search online for the answers. It&rsquo;s fairly obvious
that failing isn&rsquo;t an encouraged way to learn in the school system. This seems
toxic since people who prioritize getting the highest grade (perhaps through
shady lanes) falsely push the average grade too high thus hurting the curve
(there&rsquo;s probably some kind of logical fallacy in here).</p>

<h2>So what?</h2>

<p>I&rsquo;m guessing that my points are something that already been beaten to death by
actual educators. &ldquo;Of course cheating doesn&rsquo;t help anyone.&rdquo; Then what do you
say to the people around you who have worked their hardest to <em>not cheat</em> and
as a result got bad grades. What do you say when the people around them are
getting job offers left and right? &ldquo;Life&rsquo;s tough&rdquo;?</p>

<p>Question&rsquo;s I have are what are some assignments that you can&rsquo;t cheat on?
One-on-one oral examinations? There&rsquo;s an obvious incentive for students to
cheat, but what is the incentive for instructors to go through hoops to make
&ldquo;un-cheatable&rdquo; assignments?</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[My Blogging Setup]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/12/11/blogging-setup/"/>
    
    <updated>2013-12-11T18:36:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/12/11/blogging-setup</id>
    
    <content type="html"><![CDATA[<p>This semester I&rsquo;ve been using <a href="http://octopress.org/">octopress</a> to generate by
blog and github pages to display it. After setting it up, it&rsquo;s been pretty
painless.</p>

<p>Blog posts are simply text files which you can edit using your favorite text
editor. You then run some scripts to generate your site and deploy it to github
pages.</p>

<p>People have created some themes for octopress which makes it easy to find
something that doesn&rsquo;t burn your eyes out.</p>

<p>I haven&rsquo;t used any other blog generators before but this one seems to work
somewhat alright. It has the ability to create new pages to hold additional
information and everything can be simply stored in a git repo.</p>

<p>If I had more time, I&rsquo;d like to try out other site generators like
<a href="http://blog.getpelican.com/">pelican</a> to see what I&rsquo;m missing.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[My Coding Setup]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/12/11/my-coding-setup/"/>
    
    <updated>2013-12-11T18:26:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/12/11/my-coding-setup</id>
    
    <content type="html"><![CDATA[<p>For the past three year&rsquo;s I&rsquo;ve been using Unix as my IDE for mostly C and C++
programming.</p>

<p>The two main components are Vim and ctags.</p>

<p>Vim is a text editor that uses modal hotkeys. It took a bit to learn the basics
but it keeps your fingers on the homerow for which keeps your fingers focused
on typing. There&rsquo;s a lot of somewhat esoteric hotkeys to do stuff like change
the case of a letter that seem kind of worthless, and maybe they are, but it
seems like the ones that come in handy are the ones that stick in your brain
after a while.</p>

<p>Ctags generates a database of function names and definitions found in source
files. You can run it in your project directory and it will generate file
locations of function implementations.</p>

<p>Ctags and Vim integrate together; while in Vim you can press a variety of
hotkeys to open up and jump to the location of a functions definition. This
works great for when you don&rsquo;t understand what is going on.</p>

<p>This leaves you with all the great core Unix tools to analyze, modify or create
additional source code.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[A Balanced Brace Checker]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/11/26/a-balanced-brace-checker/"/>
    
    <updated>2013-11-26T12:30:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/11/26/a-balanced-brace-checker</id>
    
    <content type="html"><![CDATA[<p>Recently in Intro to Unix we had to implement a balanced brace checker.
Specifically, the tool was supposed to ensure that every opening brace has a
matching closing brace and vice versa.</p>

<p>This is a fairly common assignment, though I had never actually done it before.
I was introduced to in Virginia Tech&rsquo;s second year programming course (data
structures and algorithms) as an introduction to recursive (or stack) based
algorithms. I think some recent classes in Data Structures actually had this as
an assignment so I can guess why we would do it again. It lets the student see
how they could have made their original implementation follow the Unix design
philosophy.</p>

<h2>Intro to Unix&rsquo;s Position in Undergrad Curriculum</h2>

<p>Intro to Unix has an interesting position in the undergrad Computer Engineering
curriculum since it is not a pre-requisite for any class. I&rsquo;ve actually
finished taking all my programming courses this semester so it makes me wonder
the benefits of learning about fundamental design patterns so late. Of course
in future work I could apply these ideas but I believe it would have been
better to have some time to practice these ideas in school.</p>

<p>I really believe many of the core Unix design concepts are important to making
modern and scalable code, especially the concepts of modularity. In my mind,
Modularity goes hand-in-hand with code written in a <em>purely functional</em> style.</p>

<h2>Pure Functions</h2>

<p>Pure functions are completely compartmentalized: you pass in data and you get
out data. For example, I would hope the function <code>add(int a, int b)</code> is a pure
function returning  <code>a + b</code>. There are no flags in the code or assumptions
made, the function always does the same thing. There is basically no state
maintained across function calls.</p>

<h3>Parallelization</h3>

<p>This can be useful because if there is no state, or if the state is all
internal to the function, then there is no synchronization required. These are
so called embarrassingly parallel (or trivially parallel) problems. Imposing
<em>order</em> on a multi-threaded or distributed system is a expensive. The
<a href="http://www.bloom-lang.net/">Bloom</a> programming language makes it easy to see
these points of order allowing you to reduce them and make things scale.</p>

<p>John Carmack, creator of games like Doom, Quake and Commander Keen, speaking at
Quakecon 2013, outlines a similar vision for how functional programming can
aide in speedier game development for just these reasons
(<a href="http://youtu.be/1PhArSujR_A">Video</a>). Of course you don&rsquo;t actually need a
programming language that enforces pure functional style as on long as the team
you are working with does not break the rules.</p>

<p>Carmack makes the point that writing in a functional style is difficult, or
at least different, especially when coming from procedural languages like Java
or C. Its not like a team can just sit down with
<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a> and pump out thousands of
games overnight. It will take a lot of work to iron out the details of working
in this style.</p>

<h2>Our Curriculum</h2>

<p>So, how does all of this relate to our classes? If we are only briefly
introduced to design concepts, such as modularity, that are perhaps difficult
to implement but rewarding in the long run then how can we expect to use them
without more practice? I&rsquo;m guessing we&rsquo;d need some classes where we are
required to write in this style in order for it to become closer to second
nature. What about when you are introduced to these concepts right before
you&rsquo;re graduating? Will you really use them later in life?</p>

<p>Of course, being able to hack out a homework assignment or project quickly
means taking shortcuts. It means it will be held together with duct tape, and
this is how real software is made. So I&rsquo;m not really sure what the best course
of action would be.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[ASE 2013]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/11/07/ase-2013/"/>
    
    <updated>2013-11-07T15:12:00-05:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/11/07/ase-2013</id>
    
    <content type="html"><![CDATA[<p>I was very lucky to be accepted for the tool demos at Automated Software
Engineering 2013. I get to spend a week in California, hopefully eat some good
food and learn about some other work people have been doing.</p>

<h2>CCmutator</h2>

<p>Our tool is a concurrent mutant generator for C/C++ and is named CCmutator.
What it does is automatically make syntactical changes to source code in order
to (hopefully) insert bugs into a program. This may sound like a really strange
thing to do at first, but we hope our tool can be used for test case generation
for software verification algorithms.</p>

<p>Finding real world bugs is difficult. It involves going on bug trackers for
large projects like mozilla, reading bug reports, figuring out what is going
on, and wrapping your head around huge codebases that you&rsquo;ve never worked on
before. Our tool will hopefully be able to help speed this up. If you have an
input program that you understand, then we can automatically generate some
potentially buggy programs.</p>

<p>This begs the question of whether or not these mutant programs actually
represent real world bugs made by actual programmers.</p>

<p>Here is a link to the preprint for my paper if you are interested.</p>

<p><a href="https://raw.github.com/markus-kusano/markus-kusano.github.com/master/papers/CCmutator_ase2013_preprint.pdf">CCmutator ASE 2013 Preprint</a></p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[VCC: A Concurrent C Verifier]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/10/25/vcc-a-concurrent-c-verifier/"/>
    
    <updated>2013-10-25T16:59:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/10/25/vcc-a-concurrent-c-verifier</id>
    
    <content type="html"><![CDATA[<p>VCC is a project from Microsoft Research that allows a user to annotate their
code to prove certain properties. These properties can be things like pre- and
post- conditions or overflows. For example, the user could say the function
<code>divide(int a, int b)</code> should be be passed a value for <code>b</code> equal to zero.</p>

<p>The workflow is in a feedback loop: the code is verified by VCC, and if there
are errors the user either has to fix the annotations or the code itself.</p>

<p>The interesting contribution is that VCC can provide sound guarantees for
concurrent programs. The Microsoft team is aiming to get it to verify Microsoft
Hyper-V, a hypervisor, containing 60 thousand lines of code.</p>

<p>Microsoft started releasing some work as open source, but under a restrictive
license only supporting non-commercial use.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Logic Analyzer Instrumentation: Realtime Systems]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/10/11/logic-analyzer-instrumentation/"/>
    
    <updated>2013-10-11T16:45:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/10/11/logic-analyzer-instrumentation</id>
    
    <content type="html"><![CDATA[<h2>What is a Logic Analyzer</h2>

<p>A logic analyzer captures and displays digital signals. You plug in a logic
analyzer input cable on another cable carrying some digital signal and the
analyzer will store the signal over some period of time.</p>

<p>A fancy analyzer will be able to decode protocols such as I2C but this is not
the focus of this post.</p>

<h2>Debugging Realtime Systems on a Microcontroller</h2>

<p>One of the broad problems with any program, not only on microcontrollers, is
pinpointing what causes an error. The problem is exacerbated on realtime
systems because a standard debugger inserting breakpoints changes timing
characteristics and the control flow of the program. It is similar to the
non-determinism introduced into multi-threaded programs due to thread
scheduling.</p>

<p>For example, if you set a breakpoint in the middle of an I2C protocol state
machine in a state waiting for the slave to ACK or NACK could possibly cause
hardware to timeout thinking that the slave has died when in reality it was the
debugger stalling the program.</p>

<p>In the past I&rsquo;ve gotten around this by constantly move breakpoints and then
restarting the microcontroller to see control flow to pinpoint where an error
has occurred. This is obviously time consuming and involves a lot of clicking.</p>

<p>One was to see control flow on conventional programs is to create a log file.
On a microcontroller that has no display this is difficult but a similar
approach can be taken using code instrumentation.</p>

<h2>Code Instrumentation</h2>

<p>Most microcontrollers provide general purpose input/output (GPIO) pins. These
can be hooked up to a logic analyzer to act as flags for different points in a
program by setting them high or low. For example, you could add instrumentation
to drive a pin high when you are in an interrupt handler accepting incoming
data and then drive another pin high when the data is being processed outside
the interrupt handler.</p>

<p>This allows you to see <em>causality</em>. Event A stores incoming data into a buffer
and then Event B processes the data. More importantly this lets you see
failures in your causality relationships; the data comes in and is passed into
a buffer but it fails to be processed.</p>

<p>It will also provide timing information to see if you can meet your timing
requirements and also see areas of your system that are eating up a lot of time.</p>

<h2>You Don&rsquo;t Even Need a Logic Analyzer</h2>

<p>Simple code instrumentation like this can be done by driving an LED high off a
GPIO pin. This is a little bit more messy to setup and you don&rsquo;t get any buffer
to save your data (you could video tape the LEDs) but it is much cheaper than a
logic analyzer.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Partial Orders and Programming]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/09/25/partial-orders-and-programming/"/>
    
    <updated>2013-09-25T15:42:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/09/25/partial-orders-and-programming</id>
    
    <content type="html"><![CDATA[<h2>Order Relations</h2>

<p>Partial order relations are a fairly simple topic but it was one I initially
struggled with. Order relations are how you define ideas like greater than,
less than and equal to. If you are familiar with C++, you can think of this as
overloading the <code>&gt;</code>, <code>&lt;</code> and <code>==</code> operators for your class. We will first
discuss two order relations: total orders and partial orders and then discuss
how they are related to concurrent programming.</p>

<h3>Total Orders</h3>

<p>Total order relations are those used for natural numbers (1,2,3). This is a
fairly intuitive concept which has been taught to us all since Elementary
school. The key idea is that every natural number can be compared with every
other natural number as being greater than less than or equal.</p>

<p>However, there are some concepts in which each item can only be compared to a
subset of items; this is a partial order relation.</p>

<h3>Partial Orders</h3>

<p>Consider the following street addresses:</p>

<ol>
<li>479 Pennsylvania Ave.</li>
<li>481 Pennsylvania Ave.</li>
<li>1802 Oak Lane</li>
</ol>


<p>It makes sense to say that 479 Pennyslvania Ave. comes before 481 Pennsylvania
Ave but, what can you say about the order between 479 Pennsylvania Ave. and
1802 Oak Lane? Street addresses are examples of things that have a partial
order relation.</p>

<p>(the street address example comes from wikipedia&rsquo;s Partial Order page)</p>

<h2>Concurrent Software Testing</h2>

<p>So why is all this math useful? It turns out that concurrent programs can be
represented as partial orders instead of total orders.</p>

<p>One way to verify a concurrent program is to test all possible thread
schedules; if all of them result in a desired output then the program is
guaranteed to be safe. The problem is that this is an astronomically large
number of tests.</p>

<p>Since accesses to different memory locations do not effect each other, you only
need to test schedule orders for each memory location instead of all the
permutations of all the memory locations.</p>

<p>This concept is called partial order reduction and is a well studied solution
to the state explosion problem in concurrent software testing. However, it is
not a perfect solution since it still results in very long testing times for
large scale programs.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Modifying a Build System to Output LLVM IR]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/09/13/modifying-a-build-system-to-output-llvm-ir/"/>
    
    <updated>2013-09-13T15:53:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/09/13/modifying-a-build-system-to-output-llvm-ir</id>
    
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="http://llvm.org/">LLVM</a> and its intermediate representation (IR) are quickly
becoming and de facto standard for program analysis and instrumentation. This
is a guide to modify an established build system of an application to output
LLVM IR instead of machine code. Specifically, we will outline how to output
LLVM IR for an application using
<a href="https://en.wikipedia.org/wiki/GNU_build_system">autotools</a>.</p>

<h2>Requirements</h2>

<p>The requirements are:</p>

<ul>
<li>The GNU gold linker with plugin support</li>
<li>The LLVMgold plugin</li>
</ul>


<p>Detailed instructions on using the LLVM GNU gold plugin can be found
<a href="http://llvm.org/docs/GoldPlugin.html">here</a>.</p>

<p>A quick summary to check if your system has support for LLVMgold:</p>

<p>Run <code>/usr/bin/ld -v</code> and check if it reports <code>GNU gold</code>. To check if you have
plugin support run <code>/usr/bin/ld -plugin</code>; if it reports <code>missing argument</code> then
you are good to go. If it reports <code>unknown option</code> you will need to install or
build a version of GNU gold that supports plugins.</p>

<p>LLVM provides
<a href="http://llvm.org/docs/GoldPlugin.html#lto-how-to-build">documentation</a>  on
building GNU gold with plugin support and LLVMgold.</p>

<h2>LLVM&rsquo;s gold Plugin</h2>

<p><a href="https://en.wikipedia.org/wiki/Gold_(linker">gold</a>) is part of GNU binutils and
is a linker with support for link time optimization (LTO). LLVM provides a gold
plugin to preform LTO which inherently works by keeping source files as LLVM IR
until link time. At link time, the entire program can be observed and
optimized.</p>

<p>We&rsquo;re not so interested in the LTO aspects but rather the ability to keep files
as LLVM IR until link time. The end result is a set of &ldquo;object files&rdquo; which are
LLVM IR; If you want to make an LLVM pass on an entire program, this is a good
starting point but beyond the scope of this post.</p>

<h2>Autotools</h2>

<p>To work with autotools, we simply need to modify some environment variables to
specify options passed to <code>clang</code>.</p>

<p>If <code>clang</code> and <code>binutils</code> are not in your path, let <code>$PREFIX</code> be where they are
installed. <code>export</code> the following environment variables.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export CC="$PREFIX/bin/clang -emit-llvm"
</span><span class='line'>export CXX="$PREFIX/bin/clang++ -emit-llvm"
</span><span class='line'>export AR="$PREFIX/bin/ar"
</span><span class='line'>export NM="$PREFIX/bin/nm"</span></code></pre></td></tr></table></div></figure>


<p>If they are in your path, you simply need:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export CC=clang -emit-llvm
</span><span class='line'>export CXX=clang++ -emit-llvm</span></code></pre></td></tr></table></div></figure>


<p>Then, simply build the program as usual. The end result should be a set of
<code>.o</code> files which are all LLVM bitcode.</p>

<p>Without the GNU gold linker and LLVMgold plugin you will get linker errors by
using <code>-emit-llvm</code>.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Art of Unix Programming Nuggets]]></title>
    <link href="http://markus-kusano.github.io/blog/2013/08/29/art-of-unix-programming-nuggets/"/>
    
    <updated>2013-08-29T13:56:00-04:00</updated>
    <id>http://markus-kusano.github.io/blog/2013/08/29/art-of-unix-programming-nuggets</id>
    
    <content type="html"><![CDATA[<blockquote><p>One of the many consequences of the exponential power-versus-time curve in
computing, and the corresponding pace of software development, is that 50% of
what one knows becomes obsolete over every 18 months. Unix does not abolish
this phenomenon, but does do a good job of containing it. There&rsquo;s a bedrock
of unchanging basics&mdash;-languages, system calls, and tool invocations&mdash;-that
one can actually keep using for years, even decades.</p></blockquote>

<p>How much of our education here will be effected by 50% decay in 18 months? We
already are seeing courses being changed (intro to computer engineering,
digital design one and two) and there is talk about the software track (1574,
2574, 3574) being altered as well. These changes, particularly the switch to
FPGAs over programmable logic devices, give great opportunity for us to complain
about walking uphill both ways and to be arrogant about our skills in getting
WinCUPL to work (did you try turning it on and off again?); but, this isn&rsquo;t
very productive.</p>

<p>Overall, this is perhaps more of a general education question that might be
difficult to address directly in an introduction to Unix course but I think it
is an interesting thought to keep in mind while being a full-time student.</p>

<p>Related to this is:</p>

<blockquote><p>Rule of Extensibility: Design for the future, because it will be here sooner
than you think.</p></blockquote>

<p>This rule is something that can be addressed in intro to Unix. The text
surrounding this rule emphasizes quick prototyping (&ldquo;Make it run, then make it
right, then make it fast&rdquo;). My programming knowledge is largely in C/C++, which
is a very comfortable environment to me. I can hack on a python script written
by someone else but I&rsquo;m not familiar with all the different ways higher level
languages can quickly create solutions.</p>

<p>The author also talks about a strategy of making the backend a C library and
the frontend possibly a high-level language calling into this library. I think
it would be nice to learn how to do this (communication over sockets, calling C
code from python)</p>

<p>Quotes from The Art of Unix Programming.
<a href="http://catb.org/esr/writings/taoup/html/">http://catb.org/esr/writings/taoup/html/</a></p>
]]></content>
    
  </entry>
  
</feed>